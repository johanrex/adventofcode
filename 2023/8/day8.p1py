import re
import networkx as nx


def parse(filename):
    with open(filename) as f:
        line = f.readline().strip()
        moves = [c for c in line]

        # G = nx.Graph()
        G = nx.MultiDiGraph()

        line = f.readline().strip()
        assert line == ""

        for line in f:
            line = line.strip()
            if line == "":
                break
            match = re.match(r"(\w+)\s*=\s*\((\w+),\s*(\w+)\)", line)
            node_name = match.group(1)
            left = match.group(2)
            right = match.group(3)

            if not G.has_node(node_name):
                G.add_node(node_name, name=node_name)
            if not G.has_node(left):
                G.add_node(left, name=left)
            if not G.has_node(right):
                G.add_node(right, name=right)

            G.add_edge(node_name, left, label=f"{node_name}L")
            G.add_edge(node_name, right, label=f"{node_name}R")
            pass

    return moves, G


def get_next_move(moves):
    while True:
        for move in moves:
            yield move


def part1(moves, G):
    start = "AAA"
    end = "ZZZ"

    edge_lookup = {}
    edges = G.edges(data=True)

    for u, v, data in G.edges(data=True):
        pass
        edge_name = data.get("label")
        edge_lookup[edge_name] = v

    # print(edge_lookup)

    move_gen = get_next_move(moves)
    curr = start
    steps = 0

    while curr != "ZZZ":
        next_move = next(move_gen)

        key = curr + next_move
        step_to = edge_lookup[key]

        # print(f"{curr} going {next_move} to {step_to}")

        curr = step_to
        steps += 1

    print("Part 1:", steps)


# filename = "8/example"
filename = "8/input"

moves, G = parse(filename)
part1(moves, G)
